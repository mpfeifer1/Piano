This is the techinical handoff guide for the Piano project. It describes the
project and pno compilation progress in various levels of detail. The goal of
this document is to aid anyone continuing work on the Piano project by getting
them familiar with the program.

Table of contents:
- Project Backlog
- File Structure
- Setup
- Compilation
    - Parsing & Tokenizing
- Signal Generation
- Midi Generation
    - Midi Format & Mido

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

~~~~~~~~~~~~~~~
Project Backlog
~~~~~~~~~~~~~~~

MVP Features:
    - semanticAnalyzer has several utility functions unimplemented towards
        the bottom of the file.
    - implement rests in tuples (might need slight addition to grammar 
        as well)
    - Fully test chords, tuples, multiple instrumentations in a measure.
    - Double check coding standards.
    - ***WAY MORE UNIT TESTS! FOR GOD'S SAKE WE DIDN'T REALIZE 
        FLATS DIDN'T WORK UNTIL THE PROJECT WAS ALMOST DUE!!!***
        (flats are already fixed, by the way.)
    - Throw consistent errors.
    - IMPLEMENT VARIABLES.
    - Expand .gitignore (.pno, .mid, .midi, .sig, tree.txt (specifically tree.txt, not just .txt))
    - Modularize MIDI generation.

Known Bugs:
    - Chords are funky
    - Tuples are funky
    - Tempo is really slow when playing MIDI through VLC.
        Might just be a VLC problem.
    - Variables only work for instrument names and measures, nothing else.
        (see: IMPLEMENT VARIABLES.)
 
Future Features:
    - Figure out how to package as single executable rather than cloning
        the repository for distribution.
    - Add accents to notes.
    - Add first/second/.../n endings to repeats.
    - Repeat endings of variable length.
    - Add repeat start/end in middle of measure.
    - Pre-defined macro functions, like de/crescendo, grand pause, fermata, etc.
    - User defined macros?
    - Preprocessing/importing macros?
    - Add another compilation targed (other than MIDI), in general make
        the whole compiler more modular.
   

~~~~~~~~~~~~~~
File Structure
~~~~~~~~~~~~~~

The following is the file structure for the project:

/Piano

    /util  # Contains install scripts and other utilities.
        install-dependencies.bash
        install-hooks.bash
        pre-commit.bash
        run-tests.bash

    /doc   # Contains the documentation and examples for the Piano language

        /examples

            /pno   # Contains sample .pno files that can be compiled by the Piano program

            /midi  # Contains sample .mid or .midi files
        signal_specification.txt
        technicalHandoff.txt

    /src   # Contains all source code and tests for the Piano program, and the Piano executable
        piano.py   # The Piano executable

        /core      # Contains the source code for Piano

        /test      # Contains all the unit tests for Piano


~~~~~
Setup
~~~~~

Installing dependencies:
    To install the necessary dependencies, simply run ./util/install-dependencies.bash
    If you are doing development on the project, be sure to run ./util/installhooks.bash

    All necessary dependencies are listed in Piano/util/install-dependencies.bash

Running Piano:
    The Piano executable must be run within the /Piano/src directory.
    The Piano executable has 4 options/flags, one of which is required, the rest are optional:
    
        -p <filename>       The -p flag is used to specify the .pno file to be compiled.

        -o <filename>       The optional -o flag is used to specify the name of the output file.
                            Defaults to "song.pno".
        
        -t                  Creates a file "tree.txt" in which the Lark tree for the .pno file
                            is dumped.

        -s                  Creates a file "signal.sig" in which the signals for the .pno file 
                            are dumped.

    An example run would be as follows:
        ./piano -p ../doc/examples/pno/simple.pno -o helloworld.midi

    After compilation, a file called 'helloworld.midi' will appear in the current directory.

Running tests:
    Piano tests can be run in two ways. Either run ./util/run-tests.bash or python3 src/test/runtests.py

    The results of the tests will be printed to the screen.



~~~~~~~~~~~
Compilation
~~~~~~~~~~~

In order to understand how the compilation progress works, one must first understand the grammar.
The grammar itself is located in Piano/src/core/grammar.py
The grammar is written in a form of EBNF used by Lark Parser. The reference guide for Lark grammar
syntax can be found at https://lark-parser.readthedocs.io/en/latest/grammar/.

To make better sense of the grammar, sample .pno files are located in Piano/doc/examples/pno.
In-depth coverage for the syntactic structures can be found in the Piano Language Tutorial and
Piano Reference Manual.

********************
Parsing & Tokenizing
********************

Through the Lark parser, a pno file is tokenized and put into a Lark Tree with some nodes as Lark lexer.Tokens.

An example of the tree structure is as follows:

    * Example.pno file:
        Compose {
            Measure {
                acousticgrandpiano {
                    1/4 Bb5;
                }
            }
        }
    
    * Example Lark Tree (Brace yourself, it's a doozy):

        Tree(
            start, 
            [Tree(
                compose, 
                [Tree(
                    composeitems, 
                    [Tree(
                        measure, 
                        [Tree(
                            instrumentation, 
                            [Token(
                                INSTRUMENT, 
                                'acousticgrandpiano'
                            ), 
                            Tree(
                                noteitem, 
                                [Tree(
                                    note, 
                                    [Tree(
                                        division, 
                                        [Tree(
                                            number, 
                                            [Token(
                                                __ANON_3, 
                                                '1'
                                            )]
                                        ), 
                                        Tree(
                                            number, 
                                            [Token(
                                                __ANON_3, 
                                                '4'
                                            )]
                                        )]
                                    ), 
                                    Tree(
                                        notename, 
                                        [Token(
                                            __ANON_1, 
                                            'B'
                                        ), 
                                        Tree(
                                            accidental, 
                                            [Token(
                                                __ANON_0, 
                                                'b'
                                            )]
                                        ), 
                                        Tree(
                                            number, 
                                            [Token(
                                                __ANON_3, 
                                                '5'
                                            )]
                                        )]
                                    )]
                                )]
                            )]
                        )]
                    )]
                )]
            )]
        )
    
    * An easier to read example is displayed if we print tree.pretty():
       
        start
            compose
                composeitems
                measure
                    instrumentation
                    acousticgrandpiano
                    noteitem
                        note
                        division
                            number	1
                            number	4
                        notename
                            B
                            accidental	b
                            number	5
   
    * The important things to note from the above example are the following things:
        - Some "leaf nodes" are not Trees but rather Tokens. An example of that is:

            Tree(
                number,       # This example shows the subtree for a number token 
                [Token(
                    __ANON_3, # This is an anonymous token name. This doesn't matter.
                    '4'       # This is the actual data that matters.
                )]
            )]
            
            # This example is the subtree describing the '4' in the '1/4 Bb5;' line.

        - Another thing to note is that not all Token names are junk, such as the following example: 

            [Token(
                INSTRUMENT,             # This token name implies the data is a syntactic literal caled 'INSTRUMENT'.
                'acousticgrandpiano'
            ), 
            The reason this happens is due to 'acousticgrandpiano' being a pre-defined string in the language grammar:
                 INSTRUMENT:   "acousticgrandpiano"i
                    | "brightacousticpiano"i
                    | "electricgrandpiano"i
                    ...etc.
        
    * Once the input is tokenized and put in the Tree, each Subtree is validated in semanticanalysis.py. The tree is
        checked in such a way that a Tree is valid only if all of its subtrees are valid, all the way down to the
        data contained in each Token.
        In other words, if a token representing the octave number is given a value outside the range of 1-8, an 
        exception is thrown and compilation fails. This is true for any Tree containing a subtree that doesn't belong,
        or has an unexpected number of subtrees, or has a token containing invalid or out of range data. 

        - The way data is accessed in Trees and Tokens is different. Trees are accessed with Tree.data to get the 
            name, and Tree.children returns a list of Subtrees. Token.name gets the name (think 'INSTRUMENTATION' 
            or '__ANON__0') and Token.value gets the token's value.


~~~~~~~~~~~~~~~~~
Signal Generation
~~~~~~~~~~~~~~~~~

Once the Semantic analysis ensure the Tree is valid, it is then compiled into an intermediate form we call
"Signal Form", which is to midi formatting what Assembly is to Machine Code.

Signals, at their core, tell you when a note should start, and how long the note should last for. We pass 
signals around as a list of dictionaries. Each dictionary in the list represents one signal. Each signal 
contains a type, which are all listed in the signal specification document. Different types imply that 
each dictionary may contain different value fields depending on the type. 

A more in-depth description of the signal form can be found in Piano/doc/signal_specification.txt

When converting to signals, the compiler performs a depth-first search on the validated Tree. Similar to
the validation step, each structure in the language has a "to_signal" function to match its "is_valid" function.
Each "to_signal" function processes through their respective Subtrees and returns a list of their representative
signals. The subtrees (and ergo the signals) are created in chronological order,
which we get for free due to the nature of the grammar and how it's parsed.
Some "to_signal" functions call lower "to_signal" functions in the case of nested dependencies. For example,
the measure "to_signal" function will call the instrumentation "to_signal" function.

In the case of a measure, first a "measure start" signal is given, followed by a list of signals generated by
subcalls to "to_signal" functions, which are then followed by a "measure end" signal to finish off the measure.
This functionality allows our language to be extremely modular, as signal generation for a given structure is not
dependent on lower structures, but rather only relies on its own beginning and ending signal. Every structure's
signals in-between are completely independent.

~~~~~~~~~~~~~~~
Midi Generation
~~~~~~~~~~~~~~~

Once the signals are created, they can be output to a .sig file, but generally the list is passed to the Midi
generator. The Piano compiler uses the Mido library to create midi files. Mido takes in data in a format that is
very similar to our Signal format.

Each Mido note takes in a note, the instrument that plays the note, the volume of the note, and the length of time
since the end of the previous note on the track. 

During Midi Generation, each signal in the list of signals has a validation checker, similar to the trees during
semantic analysis. Also similarly to semantic analysis, each signal has a "midify" function that turns the signal
into a valid midi format.

***********
Midi Format
***********

Each midi file is composed (pun intended) of tracks and channels. One could think of a midi file as a bunch of
"messages" each with a different attributes and values, similar to the Piano signal format. In fact, a midi file
is made up of tracks, which can be thought of as specialized Python list objects, as the Mido MidiTrack object
can be treated as a list.

So a very simplified version of Midi structure looks as follows:
MidiFile --has--> Tracks
Track --has--> Messages
Messages --have--> Types, Attributes, Channels

Within each Track, there is a Time attribute, which is a delta time measured in ticks. The overall time in Midi
files is measured in ticks as well as beats. 
--!The timing of when each note begins is measured in the number of ticks since the previous note ended!--

For more information on how Midi files work and how Mido is used, visit:
https://mido.readthedocs.io/en/latest/midi_files.html

Tracks are added manually one at a time, for an example see the add_track function in Piano/src/core/midigenerator.py.

